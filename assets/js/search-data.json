{
  
  "0": {
    "title": "Access Control",
    "content": "Access Control . Authelia allows to define a fine-grained rule-based access control policy in configuration. This list of rules is tested against any requests protected by Authelia and defines the level of authentication the user must pass to get access to the resource. . For instance a rule can look like this: . - domain: dev.example.com resources: - &quot;^/groups/dev/.*$&quot; subject: &quot;group:dev&quot; policy: two_factor . This rule matches when the request targets the domain dev.example.com and the path matches the regular expression ^/groups/dev/.*$. In that case, a two-factor policy is applied requiring the user to authenticate with two factors. . Configuration . Please check the dedicated documentation .",
    "url": "https://authelia.github.io/authelia/features/access-control.html",
    "relUrl": "/features/access-control.html"
  }
  ,"1": {
    "title": "Access Control",
    "content": "Access Control . Access Control List . With Authelia you can define a list of rules that are going to be evaluated in order when authorization is delegated to Authelia. . The first matching rule of the list defines the policy applied to the resource and, if no rule matches the resource, a customizable default policy is applied. . Access Control Rule . A rule defines two things: . the matching criterion of the request presented to the reverse proxy | the policy applied when all criterion match. | . The criterion are: . domain: domain targeted by the request. | resources: list of patterns that the path should match (one is sufficient). | subject: the user or group of users to define the policy for. | networks: the network range from where should comes the request. | . A rule is matched when all criterion of the rule match . Policies . A policy represents the level of authentication the user needs to pass before being authorized to request the resource. . There exist 4 policies: . bypass: the resource is public as the user does not need any authentication to get access to it. | one_factor: the user needs to pass at least the first factor to get access to the resource. | two_factor: the user needs to pass two factors to get access to the resource. | deny: the user does not have access to the resource. | . Domains . The domains defined in rules must obviously be either a subdomain of the domain protected by Authelia or the protected domain itself. In order to match multiple subdomains, the wildcard matcher character *. can be used as prefix of the domain. For instance, to define a rule for all subdomains of example.com, one would use *.example.com in the rule. . Resources . A rule can define multiple regular expressions for matching the path of the resource. If any one of them matches, the resource criteria of the rule matches. . Subjects . A subject is a representation of a user or a group of user for who the rule should apply. . For a user with unique identifier john, the subject should be user:john and for a group uniquely identified by developers, the subject should be group:developers. Unlike resources there can be only one subject per rule. However, if multiple users or group must be matched by a rule, one can just duplicate the rule as many times as there are subjects. . Note: Any PR to make it a list instead of a single item is welcome. . Networks . A list of network ranges can be specified in a rule in order to apply different policies when requests come from different networks. . The main use case is when, let say a resource should be exposed both on the Internet and from an authenticated VPN for instance. Passing a second factor a first time to get access to the VPN and a second time to get access to the application can sometimes be cumbersome if the endpoint is not that much sensitive. . Even if Authelia provides that flexbility, you might prefer higher level of security and avoid this option entirely. You and only you can define your security policy and it’s up to you to configure Authelia accordingly. . Complete example . Here is a complete example of complex access control list that can be defined in Authelia. . access_control: default_policy: deny rules: - domain: public.example.com policy: bypass - domain: secure.example.com policy: one_factor networks: - 192.168.1.0/24 - domain: secure.example.com policy: two_factor - domain: singlefactor.example.com policy: one_factor - domain: &quot;mx2.mail.example.com&quot; subject: &quot;group:admins&quot; policy: deny - domain: &quot;*.example.com&quot; subject: &quot;group:admins&quot; policy: two_factor - domain: dev.example.com resources: - &quot;^/groups/dev/.*$&quot; subject: &quot;group:dev&quot; policy: two_factor - domain: dev.example.com resources: - &quot;^/users/john/.*$&quot; subject: &quot;user:john&quot; policy: two_factor .",
    "url": "https://authelia.github.io/authelia/configuration/access-control.html",
    "relUrl": "/configuration/access-control.html"
  }
  ,"2": {
    "title": "Architecture",
    "content": "Architecture . Authelia is a companion of reverse proxies like Nginx, Traefik and HAProxy. It can be seen as an extension of those proxies providing authentication functions and a login portal. . As shown in the following architecture diagram, Authelia is directly connected to the reverse proxy but never directly connected to application backends. . . Workflow . Reverse proxies are configured so that every incoming requests generates an authentication request sent to Authelia and to which Authelia responds to order the reverse proxy to let the incoming request pass through or block it because user is not authenticated or is not sufficiently authorized. . Step by step . When the first request of an unauthenticated user hits the reverse proxy, Authelia determines the user is not authenticated because no session cookie has been sent along with the request. Consequently, Authelia redirects the user to the authentication portal provided by Authelia itself. The user can then execute the authentication workflow using that portal to obtain a session cookie valid for all subdomains of the domain protected by Authelia. . When the user visits the initial website again, the query is sent along with the session cookie which is forwarded in the authentication request to Authelia. This time, Authelia can verify the user is authenticated and order the reverse proxy to let the query pass through. . Sequence Diagram . Here is a description of the complete workflow: . .",
    "url": "https://authelia.github.io/authelia/home/architecture.html",
    "relUrl": "/home/architecture.html"
  }
  ,"3": {
    "title": "Authelia Scripts",
    "content": "Authelia Scripts . Authelia comes with a set of dedicated scripts doing a broad range of operations such as building the distributed version of Authelia, building the Docker image, running suites, testing the code, etc… . Those scripts becomes available after sourcing the bootstrap.sh script with . source bootstrap.sh . Then, you can access the scripts usage by running the following command: . authelia-scripts --help . For instance, you can build Authelia (Go binary and frontend) with: . authelia-scripts build . Or build the official Docker image with: . authelia-scripts docker build . Or start the Standalone suite with: . authelia-scripts suites setup Standalone . You will find more information in the scripts usage helpers. .",
    "url": "https://authelia.github.io/authelia/contributing/authelia-scripts.html",
    "relUrl": "/contributing/authelia-scripts.html"
  }
  ,"4": {
    "title": "Build & Dev",
    "content": "Build &amp; Dev . Authelia is written in Go and comes with a dedicated CLI called authelia-scripts which is available after running source bootstrap.sh. This CLI provides many useful tools to help you during development. . In order to build and contribute to Authelia, you need to make sure Go v1.13, Docker, docker-compose and Node v12 are installed on your machine. . Get started . Authelia is made of Go application serving the API and a React application for the portal. . In order to ease development, Authelia uses the concept of suites to run Authelia from source code so that your patches are included. This is a kind of virtual environment running Authelia in a complete ecosystem (LDAP, Redis, SQL server). Note that Authelia is hotreloaded in the environment so that your patches are instantly included. . The next command starts the suite called Standalone: . $ authelia-scripts suites setup Standalone . Most of the suites are using docker-compose to bootstrap the environment. Therefore, you can check the logs of all application by running the following command on the component you want to monitor. . $ docker logs authelia_authelia-backend_1 -f . Then, edit the code and observe how Authelia is automatically reloaded. . Unit tests . To run the unit tests, run: . $ authelia-scripts unittest . Integration tests . Integration tests are located under the internal/suites directory and are based on Selenium. A suite is a combination of environment and tests. Executing a suite therefore means starting the environment, running the tests and tearing down the environment. Each step can be run independently: . # List the available suites $ authelia-scripts suites list Standalone DuoPush LDAP Traefik # Start the environment of Standalone suite. $ authelia-scripts suites setup Standalone # Run the tests related to the currently running suite. $ authelia-scripts suites test # Tear down the environment $ authelia-scripts suites teardown Standalone . In order to test all suites (approx 30 minutes), you need to make sure there is no currently running suite and then you should run: . $ authelia-scripts suites test . Also, you don’t need to start the suite before testing it. Given you’re not running any suite, just use the following command to test the Standalone suite. . $ authelia-scripts suites test Standalone . The suite will be spawned, tests will be run and then the suite will be teared down automatically. .",
    "url": "https://authelia.github.io/authelia/contributing/build-and-dev.html",
    "relUrl": "/contributing/build-and-dev.html"
  }
  ,"5": {
    "title": "Deployment - Highly-Available",
    "content": "Highly-Available Deployment . Authelia can be deployed on bare metal or on Kubernetes with two different kind of artifacts: the distributable version (binary and public_html) or a Docker image. . NOTE: If not done already, we highly recommend you first follow the Getting Started documentation. . On Bare Metal . Authelia has been designed to be a proxy companion handling the authentication and authorization requests for your entire infrastructure. . As Authelia will be key to your architecture, it requires several components to make it highly-available. Deploying it in production means having an LDAP server for storing the information about the users, a Redis cache to store the user sessions in a distributed manner, a SQL server like MariaDB to persist user configurations and one or more nginx reverse proxies configured to be used with Authelia. With such a setup Authelia can easily be scaled to multiple instances to evenly handle the traffic. . NOTE: If you don’t have all those components, don’t worry, there is a way to deploy Authelia with only nginx. This is described in Deployment for Devs. . Here are the available steps to deploy Authelia given the configuration file is /path/to/your/configuration.yml. Note that you can create your own configuration file from config.template.yml located at the root of the repo. . NOTE: Prefer using environment variables to set secrets in production otherwise pay attention to the permissions of the configuration file. See configuration.md for more information. . Deploy with the distributable version . # Build it if not done already $ authelia-scripts build $ PUBLIC_DIR=./dist/public_html authelia --config /path/to/your/configuration.yml . Deploy With Docker . $ docker run -v /path/to/your/configuration.yml:/etc/authelia/configuration.yml -e TZ=Europe/Paris authelia/authelia . FAQ . Why is this not automated? . Ansible would be a very good candidate to automate the installation of such an infrastructure on bare metal. We would be more than happy to review any PR on that matter. .",
    "url": "https://authelia.github.io/authelia/deployment/deployment-ha.html",
    "relUrl": "/deployment/deployment-ha.html"
  }
  ,"6": {
    "title": "Deployment - Kubernetes",
    "content": "Deployment on Kubernetes . . UNDER CONSTRUCTION .",
    "url": "https://authelia.github.io/authelia/deployment/deployment-kubernetes.html",
    "relUrl": "/deployment/deployment-kubernetes.html"
  }
  ,"7": {
    "title": "Deployment - Lite",
    "content": "Lite Deployment . Authelia can be deployed as a lite setup not requiring any SQL server, Redis cluster or LDAP server. In some cases, like protecting personal projects/websites, it can be fine to use that setup but beware that this setup is non-resilient to failures so it should be used at your own risk. . The setup is called lite since it reduces the number of components in the architecture to only two: a reverse proxy such as Nginx, Traefik or HAProxy and Authelia. . Reverse Proxy . Documentation for deploying a reverse proxy collaborating with Authelia is available here. . Discard components . Discard SQL server . It’s possible to use a SQLite file instead of a SQL server as documented here. . Discard Redis . Connection details to Redis are optional. If not provided, sessions will be stored in memory instead. This has the inconvenient of logging out users every time Authelia restarts. . The documentation about session management is available here. . Discard LDAP . Authelia can use a file backend in order to store users instead of a LDAP server or an Active Directory. . To use a file backend instead of a LDAP server, please follow the related documentation here. . FAQ . Can you give more details on why this is not suitable for production environments? . This documentation gives instructions that will make Authelia non resilient to failures and non scalable by preventing you from running multiple instances of the application. This means that Authelia won’t be able to distribute the load across multiple servers and it will prevent failover in case of a crash or an hardware issue. Moreover, users will be logged out every time Authelia restarts. . Why aren’t all those steps automated? . We would really be more than happy to review any contribution with an Ansible playbook, a Chef cookbook or whatever else to automate the process. .",
    "url": "https://authelia.github.io/authelia/deployment/deployment-lite.html",
    "relUrl": "/deployment/deployment-lite.html"
  }
  ,"8": {
    "title": "Duo Push Notifications",
    "content": "Duo Push Notifications . Authelia supports mobile push notifications relying on Duo. . Follow the instructions in the dedicated documentation to know how to set up push notifications in Authelia. . Configuration . The configuration is as follows: . duo_api: hostname: api-123456789.example.com integration_key: ABCDEF secret_key: 1234567890abcdefghifjkl . The secret key is shown as an example but you’d better set it using an environment variable as described here. .",
    "url": "https://authelia.github.io/authelia/configuration/duo-push-notifications.html",
    "relUrl": "/configuration/duo-push-notifications.html"
  }
  ,"9": {
    "title": "File",
    "content": "File . Authelia supports a file as a users database. . Configuration . Configuring Authelia to use a file is done by specifying the path to the file in the configuration file. . authentication_backend: file: path: /var/lib/authelia/users.yml . Format . The format of the file is as follows. . users: john: password: &quot;$6$rounds=500000$jgiCMRyGXzoqpxS3$w2pJeZnnH8bwW3zzvoMWtTRfQYsHbWbD/hquuQ5vUeIyl9gdwBIt6RWk2S6afBA0DPakbeWgD/4SZPiS0hYtU/&quot; email: john.doe@authelia.com groups: - admins - dev harry: password: &quot;$6$rounds=500000$jgiCMRyGXzoqpxS3$w2pJeZnnH8bwW3zzvoMWtTRfQYsHbWbD/hquuQ5vUeIyl9gdwBIt6RWk2S6afBA0DPakbeWgD/4SZPiS0hYtU/&quot; email: harry.potter@authelia.com groups: [] bob: password: &quot;$6$rounds=500000$jgiCMRyGXzoqpxS3$w2pJeZnnH8bwW3zzvoMWtTRfQYsHbWbD/hquuQ5vUeIyl9gdwBIt6RWk2S6afBA0DPakbeWgD/4SZPiS0hYtU/&quot; email: bob.dylan@authelia.com groups: - dev james: password: &quot;$6$rounds=500000$jgiCMRyGXzoqpxS3$w2pJeZnnH8bwW3zzvoMWtTRfQYsHbWbD/hquuQ5vUeIyl9gdwBIt6RWk2S6afBA0DPakbeWgD/4SZPiS0hYtU/&quot; email: james.dean@authelia.com . This file should be set with read/write permissions as it could be updated by users resetting their passwords. . Passwords . The file contains hash of passwords instead of plain text passwords for security reasons. . You can use authelia binary or docker image to generate the hash of any password. . For instance, with the docker image, just run . $ docker run authelia/authelia:latest authelia hash-password yourpassword $6$rounds=50000$BpLnfgDsc2WD8F2q$be7OyobnQ8K09dyDiGjY.cULh4yDePMh6CUMpLwF4WHTJmLcPE2ijM2ZsqZL.hVAANojEfDu3sU9u9uD7AeBJ/ . ## Password Hash Function . The only supported hash function is salted sha512 determined by the prefix $6$ as described in this wiki page. . Although not the best hash function, Salted SHA512 is a decent algorithm given the number of rounds is big enough. It’s not the best because the difficulty to crack the hash does not on the performance of the machine. The best algorithm, Argon2 does though. It won the Password Hashing Competition in 2015 and is now considered the best hashing function. There is an open issue to add support for this hashing function. .",
    "url": "https://authelia.github.io/authelia/configuration/authentication/file.html",
    "relUrl": "/configuration/authentication/file.html"
  }
  ,"10": {
    "title": "Filesystem",
    "content": "Filesystem . With this configuration, the message will be sent to a file. This option should be used only for testing purpose. . notifier: filesystem: filename: /tmp/authelia/notification.txt .",
    "url": "https://authelia.github.io/authelia/configuration/notifier/filesystem.html",
    "relUrl": "/configuration/notifier/filesystem.html"
  }
  ,"11": {
    "title": "First Factor",
    "content": "First Factor . 2-Factor authentication is a method in which a user is granted access by presenting two pieces of evidence that she is who she claims to be. . Authelia requires usual username and password as a first factor. . . IMPORTANT: This is the only method available as first factor. . Authelia supports several kind of users databases: . An LDAP server like OpenLDAP or OpenAM. | An Active Directory. | A YAML file | .",
    "url": "https://authelia.github.io/authelia/features/first-factor.html",
    "relUrl": "/features/first-factor.html"
  }
  ,"12": {
    "title": "Getting Started",
    "content": "Getting Started . Authelia can be tested in a matter of seconds with Docker and docker-compose. . In order to deploy the current version of Authelia locally, run the following command and follow the instructions of bootstrap.sh: . $ source bootstrap.sh . Then, start the Standalone suite. . $ authelia-scripts suites setup Standalone . A suite is kind of a virtual environment for running Authelia in a complete ecosystem. If you want more details please read the related documentation. . Test it! . After few seconds the services should be running and you should be able to visit https://home.example.com:8080/. . When accessing the login page, since this is a test environment a self-signed certificate exception should appear, it has to be trusted before you can get to the home page. The certificate must also be trusted for each subdomain, therefore it is normal to see this exception several times. . Below is what the login page looks like after you accepted all exceptions: . . You can use one of the users listed in https://home.example.com:8080/. The rights granted to each user and group is also provided in the page as a list of rules. . At some point, you’ll be required to register your second factor device. Since your security is Authelia’s priority, it will send an email to the email address of the user to confirm the user identity. Since you are running a test environment, a fake webmail called MailCatcher has been deployed for you to check out the email and confirm your identity. The webmail is accessible at http://mail.example.com:8080. . Enjoy! . FAQ . What version of Docker and docker-compose should I use? . Here are the versions used for testing in Buildkite: . $ docker --version Docker version 19.03.5, build 633a0ea838 $ docker-compose --version docker-compose version 1.24.1, build unknown . How can I serve my application under example.com? . Don’t worry, you don’t need to own the domain example.com to test Authelia. Copy the following lines in your /etc/hosts. . 192.168.240.100 home.example.com 192.168.240.100 login.example.com 192.168.240.100 singlefactor.example.com 192.168.240.100 public.example.com 192.168.240.100 secure.example.com 192.168.240.100 mail.example.com 192.168.240.100 mx1.mail.example.com . 192.168.240.100 is the IP attributed by Docker to the reverse proxy. Once done you can access the listed sub-domains from your browser and they will target the reverse proxy. . What should I do if I want to contribute? . You can refer to the dedicated documentation here. .",
    "url": "https://authelia.github.io/authelia/getting-started.html",
    "relUrl": "/getting-started.html"
  }
  ,"13": {
    "title": "Google Analytics",
    "content": "Google Analytics . It is possible to provide a Google Analytics ID to Authelia in order to monitor the usage of the Sign-In portal. . google_analytics: UA-00000-01 .",
    "url": "https://authelia.github.io/authelia/configuration/google-analytics.html",
    "relUrl": "/configuration/google-analytics.html"
  }
  ,"14": {
    "title": "HAProxy",
    "content": "HAProxy . HAProxy is a reverse proxy supported by Authelia. . UNDER CONSTRUCTION .",
    "url": "https://authelia.github.io/authelia/deployment/supported-proxies/haproxy.html",
    "relUrl": "/deployment/supported-proxies/haproxy.html"
  }
  ,"15": {
    "title": "Security",
    "content": "Security .",
    "url": "https://authelia.github.io/authelia/security/",
    "relUrl": "/security/"
  }
  ,"16": {
    "title": "Second Factor",
    "content": "Second Factor . There are multiple supported options for the second factor. . Time-based One-Time passwords with Google Authenticator | Security Keys with tokens like Yubikey. | Push notifications on your mobile using Duo. | . .",
    "url": "https://authelia.github.io/authelia/features/2fa/",
    "relUrl": "/features/2fa/"
  }
  ,"17": {
    "title": "Features",
    "content": "Features . Authelia is a 2FA &amp; SSO authentication server which is dedicated to the security of applications and users. It can be considered as an extension of reverse proxies by providing features specific to authentication. You will find among other features: . Multiple two-factor methods. | Identity verification when registering second factor devices. | Reset password. | Ban account after too many attempts (known as regulation). | .",
    "url": "https://authelia.github.io/authelia/features/",
    "relUrl": "/features/"
  }
  ,"18": {
    "title": "Storage backends",
    "content": "Storage backends . Authelia supports multiple storage backends. This backend is used to store user preferences, 2FA device handles and secrets, authentication logs, etc… . The available options are: . SQLite | MariaDB | MySQL (#512) | Postgres | .",
    "url": "https://authelia.github.io/authelia/configuration/storage/",
    "relUrl": "/configuration/storage/"
  }
  ,"19": {
    "title": "Notifier",
    "content": "Notifier . Authelia sometimes needs to send messages to users in order to verify their identity. .",
    "url": "https://authelia.github.io/authelia/configuration/notifier/",
    "relUrl": "/configuration/notifier/"
  }
  ,"20": {
    "title": "Authentication backends",
    "content": "Authentication Backends . There are two ways to store the users along with their password: . LDAP: users are stored in remote servers like OpenLDAP, OpenAM or Microsoft Active Directory. | File: users are stored in YAML file with a hashed version of their password. | .",
    "url": "https://authelia.github.io/authelia/configuration/authentication/",
    "relUrl": "/configuration/authentication/"
  }
  ,"21": {
    "title": "Configuration",
    "content": "Configuration . Authelia uses a YAML file as configuration file. A template with all possible options can be found here, at the root of the repository. . When running Authelia, you can specify your configuration by passing the file path as shown below. . $ authelia --config config.custom.yml .",
    "url": "https://authelia.github.io/authelia/configuration/",
    "relUrl": "/configuration/"
  }
  ,"22": {
    "title": "Contributing",
    "content": "Contributing .",
    "url": "https://authelia.github.io/authelia/contributing/",
    "relUrl": "/contributing/"
  }
  ,"23": {
    "title": "Supported Proxies",
    "content": "Supported Proxies . Authelia works in collaboration with reverse proxies. Here you can find the documentation of the configuration required for every supported proxies. .",
    "url": "https://authelia.github.io/authelia/deployment/supported-proxies/",
    "relUrl": "/deployment/supported-proxies/"
  }
  ,"24": {
    "title": "Deployment",
    "content": "Deployment .",
    "url": "https://authelia.github.io/authelia/deployment/",
    "relUrl": "/deployment/"
  }
  ,"25": {
    "title": "Home",
    "content": "Home . It has never been so easy to secure your applications with Single Sign-On and Two-Factor. . With Authelia you can login once and get access to all your web apps safely from the Web thanks to two-factor authentication. . . Authelia is an open source authentication and authorization server protecting modern web applications by collaborating with reverse proxies such as NGINX, Traefik and HAProxy. Consequently, no code is required to protect your apps. . . Multiple 2-factor methods are available for satisfying every users. . Time-based One-Time passwords with Google Authenticator. | Security Keys with tokens like Yubikey. | Push notifications on your mobile using Duo. | . Authelia is available as Docker images, static binaries and AUR packages so that you can test it in minutes. Let’s begin with the Getting Started. . Authelia… . is not an OAuth or OpenID Connect provider yet. | is not a SAML provider yet. | does not support support authentication against an OAuth or OpenID Connect provider. | does not support using hardware devices as single factor. | does not allow provide a PAM module yet. | .",
    "url": "https://authelia.github.io/authelia/",
    "relUrl": "/"
  }
  ,"26": {
    "title": "LDAP",
    "content": "LDAP . Authelia supports using a LDAP server as the users database. . Configuration . Configuration of the LDAP backend is done as follows . authentication_backend: ldap: # The url to the ldap server. Scheme can be ldap:// or ldaps:// url: ldap://127.0.0.1 # Skip verifying the server certificate (to allow self-signed certificate). skip_verify: false # The base dn for every entries base_dn: dc=example,dc=com # An additional dn to define the scope to all users additional_users_dn: ou=users # The users filter used to find the user DN # {0} is a matcher replaced by username. # &#39;cn={0}&#39; by default. users_filter: (cn={0}) # An additional dn to define the scope of groups additional_groups_dn: ou=groups # The groups filter used for retrieving groups of a given user. # {0} is a matcher replaced by username. # {dn} is a matcher replaced by user DN. # {uid} is a matcher replaced by user uid. # &#39;member={dn}&#39; by default. groups_filter: (&amp;(member={dn})(objectclass=groupOfNames)) # The attribute holding the name of the group group_name_attribute: cn # The attribute holding the mail address of the user mail_attribute: mail # The username and password of the admin user. user: cn=admin,dc=example,dc=com # This secret can also be set using the env variables AUTHELIA_AUTHENTICATION_BACKEND_LDAP_PASSWORD password: password . The user must have an email address in order for Authelia to perform identity verification when password reset request is initiated or when a second factor device is registered. .",
    "url": "https://authelia.github.io/authelia/configuration/authentication/ldap.html",
    "relUrl": "/configuration/authentication/ldap.html"
  }
  ,"27": {
    "title": "MariaDB",
    "content": "MariaDB . storage: mysql: host: 127.0.0.1 port: 3306 database: authelia username: authelia # This secret can also be set using the env variables AUTHELIA_STORAGE_MYSQL_PASSWORD password: mypassword .",
    "url": "https://authelia.github.io/authelia/configuration/storage/mariadb.html",
    "relUrl": "/configuration/storage/mariadb.html"
  }
  ,"28": {
    "title": "Security Measures",
    "content": "Security Measures . Protection against cookie theft . Authelia uses two mechanisms to protect against cookie theft: . session attribute httpOnly set to true make client-side code unable to read the cookie. | session attribute secure ensure the cookie will never be sent over an insecure HTTP connections. | Protection against multi-domain cookie attacks . Since Authelia uses multi-domain cookies to perform single sign-on, an attacker who poisoned a user’s DNS cache can easily retrieve the user’s cookies by making the user send a request to one of the attacker’s IPs. . To mitigate this risk, it’s advisable to only use HTTPS connections with valid certificates and enforce it with HTTP Strict Transport Security (HSTS) so that the attacker must also require the certificate to retrieve the cookies. . Note that using HSTS has consequences. That’s why you should read the blog post nginx has written on HSTS. . Notifier security measures (SMTP) . By default the SMTP Notifier implementation does not allow connections that are not secure. As such all connections require the following: . TLS Connection (STARTTLS or SMTPS) has been negotiated before authentication or sending emails (unauthenticated connections require it as well) | Valid X509 Certificate presented to the client during the TLS handshake | There is an option to disable both of these security measures however they are not recommended. You should only do this in a situation where you control all networks between Authelia and the SMTP server. The following configuration options exist to configure the security level: . SMTPS vs STARTTLS . By default all connections start as plain text and are upgraded via STARTTLS. SMTPS is supported, however due to the fact it was basically considered deprecated before the turn of the century, there is no way to configure it. It happens automatically when a SMTP notifier is configured with the SMTPS port of 465. . Configuration Option: disable_verify_cert . This is a YAML boolean type (true/false, y/n, 1/0, etc). This disables the X509 PKI verification mechanism. We recommend using the trusted_cert option over this, as disabling this security feature makes you vulnerable to MITM attacks. . Configuration Option: disable_require_tls . This is a YAML boolean type (true/false, y/n, 1/0, etc). This disables the requirement that all connections must be over TLS. This is only usable currently with authentication disabled (comment the password) and as such is only an option for SMTP servers that allow unauthenticated relay (bad practice). . Configuration Option: trusted_cert . This is a YAML string type. This specifies the file location of a pub certificate that can be used to validate the authenticity of a server with a self signed certificate. This can either be the public cert of the certificate authority used to sign the certificate or the public key itself. They must be in the PEM format. The certificate is added in addition to the certificates trusted by the host machine. If the certificate is invalid, inaccessible, or is otherwise not configured; Authelia just uses the hosts certificates. . Explanation . There are a few reasons for the security measures implemented: . Transmitting username’s and passwords over plain-text is an obvious vulnerability | The emails generated by Authelia, if transmitted in plain-text could allow an attacker to intercept a link used to setup 2FA; which reduces security | Not validating the identity of the server allows man-in-the-middle attacks | More protections measures with Nginx . You can also apply the following headers to your nginx configuration for improving security. Please read the documentation of those headers before applying them blindly. . # We don&#39;t want any credentials / TOTP secret key / QR code to be cached by # the client add_header Cache-Control &quot;no-store&quot;; add_header Pragma &quot;no-cache&quot;; # Clickjacking / XSS protection # We don&#39;t want Authelia&#39;s login page to be rendered within a &lt;frame&gt;, # &lt;iframe&gt; or &lt;object&gt; from an external website. add_header X-Frame-Options &quot;SAMEORIGIN&quot;; # Block pages from loading when they detect reflected XSS attacks. add_header X-XSS-Protection &quot;1; mode=block&quot;; .",
    "url": "https://authelia.github.io/authelia/security/measures.html",
    "relUrl": "/security/measures.html"
  }
  ,"29": {
    "title": "Miscellaneous",
    "content": "Miscellaneous . Here are the main customizable options in Authelia. . Host &amp; Port . optional: true . Defines the address to listen on. . host: 0.0.0.0 port: 9091 . Logs level . optional: true . Defines the level of logs used by Authelia. This level can be set to trace, debug, info. . logs_level: debug . JWT Secret . optional: false . Defines the secret used to craft JWT tokens leveraged by the identity verification process . jwt_secret: v3ry_important_s3cr3t . Default redirection URL . optional: true . The default redirection URL is the URL where users are redirected when Authelia cannot detect the target URL where the user was heading. . In a normal authentication workflow, a user tries to access a website and she gets redirected to the sign-in portal in order to authenticate. Since the user initially targeted a website, the portal knows where the user was heading and can redirect her after the authentication process. However, when a user visits the sign in portal directly, the portal considers the targeted website is the portal. In that case and if the default redirection URL is configured, the user is redirected to that URL. If not defined, the user is not redirected after authentication. .",
    "url": "https://authelia.github.io/authelia/configuration/miscellaneous.html",
    "relUrl": "/configuration/miscellaneous.html"
  }
  ,"30": {
    "title": "Nginx",
    "content": "Nginx . nginx is a reverse proxy supported by Authelia. . Configuration . Below you will find commented examples of the following configuration: . Authelia portal | Protected endpoint (Nextcloud) | Supplementary config | . With the below configuration you can add authelia.conf to virtual hosts to support protection with Authelia. auth.conf is utilised to enable the protection either at the root location or a more specific location/route. proxy.conf is included just for completeness. . Supplementary config . authelia.conf . # Virtual endpoint created by nginx to forward auth requests. location /authelia { internal; set $upstream_authelia http://authelia:9091/api/verify; proxy_pass_request_body off; proxy_pass $upstream_authelia; proxy_set_header Content-Length &quot;&quot;; # Timeout if the real server is dead proxy_next_upstream error timeout invalid_header http_500 http_502 http_503; # [REQUIRED] Needed by Authelia to check authorizations of the resource. # Provide either X-Original-URL and X-Forwarded-Proto or # X-Forwarded-Proto, X-Forwarded-Host and X-Forwarded-Uri or both. # Those headers will be used by Authelia to deduce the target url of the user. # Basic Proxy Config client_body_buffer_size 128k; proxy_set_header Host $host; proxy_set_header X-Original-URL $scheme://$http_host$request_uri; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $remote_addr; proxy_set_header X-Forwarded-Proto $scheme; proxy_set_header X-Forwarded-Host $http_host; proxy_set_header X-Forwarded-Uri $request_uri; proxy_set_header X-Forwarded-Ssl on; proxy_redirect http:// $scheme://; proxy_http_version 1.1; proxy_set_header Connection &quot;&quot;; proxy_cache_bypass $cookie_session; proxy_no_cache $cookie_session; proxy_buffers 4 32k; # Advanced Proxy Config send_timeout 5m; proxy_read_timeout 240; proxy_send_timeout 240; proxy_connect_timeout 240; } . auth.conf . # Basic Authelia Config # Send a subsequent request to Authelia to verify if the user is authenticated # and has the right permissions to access the resource. auth_request /authelia; # Set the `target_url` variable based on the request. It will be used to build the portal # URL with the correct redirection parameter. auth_request_set $target_url $scheme://$http_host$request_uri; # Set the X-Forwarded-User and X-Forwarded-Groups with the headers # returned by Authelia for the backends which can consume them. # This is not safe, as the backend must make sure that they come from the # proxy. In the future, it&#39;s gonna be safe to just use OAuth. auth_request_set $user $upstream_http_remote_user; auth_request_set $groups $upstream_http_remote_groups; proxy_set_header X-Forwarded-User $user; proxy_set_header X-Forwarded-Groups $groups; # If Authelia returns 401, then nginx redirects the user to the login portal. # If it returns 200, then the request pass through to the backend. # For other type of errors, nginx will handle them as usual. error_page 401 =302 https://auth.example.com/?rd=$target_url; . proxy.conf . client_body_buffer_size 128k; #Timeout if the real server is dead proxy_next_upstream error timeout invalid_header http_500 http_502 http_503; # Advanced Proxy Config send_timeout 5m; proxy_read_timeout 360; proxy_send_timeout 360; proxy_connect_timeout 360; # Basic Proxy Config proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header X-Forwarded-Proto $scheme; proxy_set_header X-Forwarded-Host $http_host; proxy_set_header X-Forwarded-Uri $request_uri; proxy_set_header X-Forwarded-Ssl on; proxy_redirect http:// $scheme://; proxy_http_version 1.1; proxy_set_header Connection &quot;&quot;; proxy_cache_bypass $cookie_session; proxy_no_cache $cookie_session; proxy_buffers 64 256k; # If behind reverse proxy, forwards the correct IP set_real_ip_from 10.0.0.0/8; set_real_ip_from 172.0.0.0/8; set_real_ip_from 192.168.0.0/16; set_real_ip_from fc00::/7; real_ip_header X-Forwarded-For; real_ip_recursive on; . Authelia Portal . server { server_name auth.example.com; listen 80; return 301 https://$server_name$request_uri; } server { server_name auth.example.com; listen 443 ssl http2; include /config/nginx/ssl.conf; location / { set $upstream_authelia http://authelia:9091; # This example assumes a Docker deployment proxy_pass $upstream_authelia; include /config/nginx/proxy.conf; # } } . Protected Endpoint . server { server_name nextcloud.example.com; listen 80; return 301 https://$server_name$request_uri; } server { server_name nextcloud.example.com; listen 443 ssl http2; include /config/nginx/ssl.conf; include /config/nginx/authelia.conf; # Virtual endpoint to forward auth requests location / { set $upstream_nextcloud https://nextcloud; proxy_pass $upstream_nextcloud; include /config/nginx/auth.conf; # Activates Authelia for specified route/location, please ensure you have setup the domain in your configuration.yml include /config/nginx/proxy.conf; # Reverse proxy configuration } } .",
    "url": "https://authelia.github.io/authelia/deployment/supported-proxies/nginx.html",
    "relUrl": "/deployment/supported-proxies/nginx.html"
  }
  ,"31": {
    "title": "One-Time Password",
    "content": "Time-based One-Time Password . Authelia supports Time-base one-time password generated by apps like Google Authenticator. . . After having successfully completed the first factor, select One-Time Password method option and click on Not registered yet? link. This will send you an e-mail to confirm your identity. . NOTE: If you’re testing Authelia, this e-mail has likely been sent to the mailbox available at https://mail.example.com:8080/ . Once this validation step is completed, a QRCode gets displayed. . . You can then use Google Authenticator to scan the code in order to register your device. . From now on, you get tokens generated every 30 seconds that you can use to validate the second factor in Authelia. .",
    "url": "https://authelia.github.io/authelia/features/2fa/one-time-password.html",
    "relUrl": "/features/2fa/one-time-password.html"
  }
  ,"32": {
    "title": "One-Time Password",
    "content": "One-Time Password . Applications generating one-time passwords usually displays an issuer to differentiate the various applications registered by the user. . Authelia allows to customize the issuer to differentiate the entry created by Authelia from others. . totp: issuer: authelia.com .",
    "url": "https://authelia.github.io/authelia/configuration/one-time-password.html",
    "relUrl": "/configuration/one-time-password.html"
  }
  ,"33": {
    "title": "Password Reset",
    "content": "Password Reset . Authelia provides workflow to let users reset their password when they lose it. . A simple click on Forgot password? for starting the process. Note that resetting a password requires a new identity verification using the e-mail of the user. . . Give your username and receive an e-mail to verify your identity. . . Once your identity is verified, fill in the form to reset your password. . . Now you can authenticate with your new credentials. .",
    "url": "https://authelia.github.io/authelia/features/password-reset.html",
    "relUrl": "/features/password-reset.html"
  }
  ,"34": {
    "title": "PostgreSQL",
    "content": "PostgreSQL . storage: postgres: host: 127.0.0.1 port: 3306 database: authelia username: authelia # This secret can also be set using the env variables AUTHELIA_STORAGE_POSTGRES_PASSWORD password: mypassword .",
    "url": "https://authelia.github.io/authelia/configuration/storage/postgres.html",
    "relUrl": "/configuration/storage/postgres.html"
  }
  ,"35": {
    "title": "Push Notification",
    "content": "Mobile Push Notification . Mobile push notifications is the new trendy second factor method. When second factor is requested by Authelia, a notification is sent on your phone that you can either accept or deny. . . Authelia leverages Duo third party to provide this feature. . First, sign up on their website, log in, create a user account and attach it a mobile device. Beware that the name of the user must match the name of the user in Authelia. . Then, in Duo interface, click on Applications and Protect an Application. Select the option Partner Auth API. This will generate an integration key, a secret key and a hostname. You can set the name of the application to Authelia and then you must add the generated information to Authelia configuration as shown below: . duo_api: hostname: api-123456789.example.com integration_key: ABCDEF secret_key: 1234567890abcdefghifjkl . Now that Authelia is configured, pass the first factor and select the Push notification option. . . You should now receive a notification on your mobile phone with all the details about the authentication request. . Limitation . Users must be enrolled via the Duo Admin panel, they cannot enroll a device from Authelia yet. . FAQ . Why don’t I have access to the Push Notification option? . It’s likely that you have not configured Authelia correctly. Please read this documentation again and be sure you had a look at config.template.yml. .",
    "url": "https://authelia.github.io/authelia/features/2fa/push-notifications.html",
    "relUrl": "/features/2fa/push-notifications.html"
  }
  ,"36": {
    "title": "Regulation",
    "content": "Regulation . Authelia takes the security of users very seriously and comes with a way to avoid brute forcing the first factor by regulating the authentication attempts and temporarily ban an account when too many attempts have been made. . Configuration . Please check the dedicated documentation. .",
    "url": "https://authelia.github.io/authelia/features/regulation.html",
    "relUrl": "/features/regulation.html"
  }
  ,"37": {
    "title": "Regulation",
    "content": "Regulation . Authelia can temporarily ban accounts when there was too many authentication attempts. This helps prevent brute force attacks. . ## Configuration . regulation: # The number of failed login attempts before user is banned. # Set it to 0 to disable regulation. max_retries: 3 # The time range during which the user can attempt login before being banned. # The user is banned if the authentication failed `max_retries` times in a `find_time` seconds window. find_time: 120 # The length of time before a banned user can sign in again. ban_time: 300 .",
    "url": "https://authelia.github.io/authelia/configuration/regulation.html",
    "relUrl": "/configuration/regulation.html"
  }
  ,"38": {
    "title": "Report Vulnerabilities",
    "content": "Report Vulnerabilities . Security is taken very seriously here, therefore we follow the rule of responsible disclosure and we encourage you to do so. . Would you like to report any vulnerability discovered in Authelia, please first contact clems4ever on Matrix or by email. .",
    "url": "https://authelia.github.io/authelia/security/report.html",
    "relUrl": "/security/report.html"
  }
  ,"39": {
    "title": "Secrets",
    "content": "Secrets . Configuration of Authelia requires some secrets and passwords. Even if they can be set in the configuration file, the recommended way to set secrets is to use environment variables as described below. . Environment variables . A secret can be configured using an environment variable with name starting with AUTHELIA_ and followed by the path of the option capitalized and with dots replaced by underscores. . For instance the LDAP password is identified by the path authentication_backend.ldap.password, so this password could alternatively be set using the environment variable called AUTHELIA_AUTHENTICATION_BACKEND_LDAP_PASSWORD. . Here is the list of the environment variables which are considered secrets and can be defined. Any other option defined using an environment variable will not be replaced. . AUTHELIA_JWT_SECRET | AUTHELIA_DUO_API_SECRET_KEY | AUTHELIA_SESSION_SECRET | AUTHELIA_AUTHENTICATION_BACKEND_LDAP_PASSWORD | AUTHELIA_NOTIFIER_SMTP_PASSWORD | AUTHELIA_SESSION_REDIS_PASSWORD | AUTHELIA_STORAGE_MYSQL_PASSWORD | AUTHELIA_STORAGE_POSTGRES_PASSWORD | . Secrets in configuration file . If for some reason you prefer keeping the secrets in the configuration file, be sure to apply the right permissions to the file in order to prevent secret leaks if an another application gets compromised on your server. The UNIX permissions should probably be something like 600. .",
    "url": "https://authelia.github.io/authelia/configuration/secrets.html",
    "relUrl": "/configuration/secrets.html"
  }
  ,"40": {
    "title": "Security Keys",
    "content": "Security Keys . Authelia supports hardware-based second factors leveraging security keys like Yubikeys. . Security keys are among the most secure second factor. This method is already supported by many major applications and platforms like Google, Facebook, Github, some banks, and much more… . . Normally, the protocol requires your security key to be enrolled on each site before being able to authenticate with it. Since Authelia provides Single Sign-On, your users will need to enroll their device only once to get access to all your applications. . . After having successfully passed the first factor, select Security Key method and click on Not registered yet? link. This will send you an email to verify your identity. . NOTE: This e-mail has likely been sent to the mailbox at https://mail.example.com:8080/ if you’re testing Authelia. . Confirm your identity by clicking on Register and you’ll be asked to touch the token of your security key to complete the enrollment. . Upon successful enrollment, you can authenticate using your security key by simply touching the token again when requested: . . Easy, right?! . FAQ . Why don’t I have access to the Security Key option? . U2F protocol is a new protocol that is only supported by recent browsers and might even be enabled on some of them. Please be sure your browser supports U2F and that the feature is enabled to make the option available in Authelia. .",
    "url": "https://authelia.github.io/authelia/features/2fa/security-key.html",
    "relUrl": "/features/2fa/security-key.html"
  }
  ,"41": {
    "title": "Session",
    "content": "Session . Authelia relies on session cookies to authenticate users. When the user visits a website of the protected domain example.com for the first time, Authelia detects that there is no cookie for that user. Consequently, Authelia redirects the user to the login portal through which the user should authenticate to get a cookie which is valid for *.example.com, meaning all websites of the domain. At the next request, Authelia receives the cookie associated to the authenticated user and can then order the reverse proxy to let the request pass through to the application. . Configuration . session: # The name of the session cookie. (default: authelia_session). name: authelia_session # The secret to encrypt the session cookie. # This secret can also be set using the env variables AUTHELIA_SESSION_SECRET secret: unsecure_session_secret # The time in seconds before the cookie expires and session is reset. expiration: 3600 # 1 hour # The inactivity time in seconds before the session is reset. inactivity: 300 # 5 minutes # The domain to protect. # Note: the login portal must also be a subdomain of that domain. domain: example.com # The redis connection details (optional) # If not provided, sessions will be stored in memory redis: host: 127.0.0.1 port: 6379 # This secret can also be set using the env variables AUTHELIA_SESSION_REDIS_PASSWORD password: authelia .",
    "url": "https://authelia.github.io/authelia/configuration/session.html",
    "relUrl": "/configuration/session.html"
  }
  ,"42": {
    "title": "Single Factor",
    "content": "Single Factor . Authelia supports single factor authentication to let applications send authenticated requests to other applications. . Single or two-factor authentication can be configured per resource of an application for flexibility. . For instance, you can configure Authelia to grant access to all resources matching app1.example.com/api/(.*) with only a single factor and all resources matching app1.example.com/admin with two factors. . To know more about the configuration of the feature, please visit the documentation about the configuration. . Proxy-Authorization header . Authelia reads credentials from the header Proxy-Authorization instead of the usual Authorization header. This is because in some circumstances both Authelia and the application could require authentication in order to provide specific authorizations at the level of the application. .",
    "url": "https://authelia.github.io/authelia/features/single-factor.html",
    "relUrl": "/features/single-factor.html"
  }
  ,"43": {
    "title": "SMTP",
    "content": "SMTP . Authelia can send emails to users through an SMTP server. It can be configured as described below. . notifier: # Use a SMTP server for sending notifications. Authelia uses PLAIN or LOGIN method to authenticate. # [Security] By default Authelia will: # - force all SMTP connections over TLS including unauthenticated connections # - use the disable_require_tls boolean value to disable this requirement (only works for unauthenticated connections) # - validate the SMTP server x509 certificate during the TLS handshake against the hosts trusted certificates # - trusted_cert option: # - this is a string value, that may specify the path of a PEM format cert, it is completely optional # - if it is not set, a blank string, or an invalid path; will still trust the host machine/containers cert store # - defaults to the host machine (or docker container&#39;s) trusted certificate chain for validation # - use the trusted_cert string value to specify the path of a PEM format public cert to trust in addition to the hosts trusted certificates # - use the disable_verify_cert boolean value to disable the validation (prefer the trusted_cert option as it&#39;s more secure) smtp: username: test # This secret can also be set using the env variables AUTHELIA_NOTIFIER_SMTP_PASSWORD password: password host: 127.0.0.1 port: 1025 sender: admin@example.com ## disable_require_tls: false ## disable_verify_cert: false ## trusted_cert: &quot;&quot; . ## Using Gmail . You need to generate an app password in order to use Gmail SMTP servers. The process is described here . notifier: smtp: username: myaccount@gmail.com # This secret can also be set using the env variables AUTHELIA_NOTIFIER_SMTP_PASSWORD password: yourapppassword sender: admin@example.com host: smtp.gmail.com port: 587 .",
    "url": "https://authelia.github.io/authelia/configuration/notifier/smtp.html",
    "relUrl": "/configuration/notifier/smtp.html"
  }
  ,"44": {
    "title": "SQLite",
    "content": "SQLite . If you don’t have a SQL server, you can use SQLite. However please note that this setup will prevent you from running multiple instances of Authelia since the database will be a local file. . ## Configuration . Just give the path to the sqlite database. It will be created if the file does not exist. . storage: local: path: /var/lib/authelia/db.sqlite3 .",
    "url": "https://authelia.github.io/authelia/configuration/storage/sqlite.html",
    "relUrl": "/configuration/storage/sqlite.html"
  }
  ,"45": {
    "title": "Suites",
    "content": "Suites . Authelia is a single component in interaction with many others in a complete ecosystem. Consequently, testing the features is not as easy as we might think. In order to solve this problem, Authelia came up with the concept of suite which is a kind of virtual environment for Authelia and a set of tests. A suite can setup components such as nginx, redis or mariadb in which Authelia can run and be tested. . This abstraction allows to prepare an environment for manual testing during development and also to craft and run integration tests efficiently. . Start a suite. . Starting a suite called Standalone is done with the following command: . $ authelia-scripts suites setup Standalone . This command deploys the environment of the suite. . Run tests of a suite . Run tests of running suite . If a suite is already running, you can simply type the test command that will run the test related to the currently running suite: . $ authelia-scripts suites test . Run tests of non-running suite . However, if no suite is running yet and you just want to run the tests of a specific suite like HighAvailability, you can do so with the next command: . # Set up the env, run the tests and tear down the env $ authelia-scripts suites test HighAvailability . Run all tests of all suites . Running all tests is easy. Make sure that no suite is already running and run: . authelia-scripts suites test . Run tests in headless mode . As you might have noticed, the tests are run using chromedriver and selenium. It means that the tests open an instance of Chrome that might interfere with your other activities. In order to run the tests in headless mode to avoid the interference, use the following command: . $ authelia-scripts suites test --headless . Create a suite . Creating a suite is as easy. Let’s take the example of the Standalone suite: . suite_standalone.go - It defines the setup and teardown phases. It likely uses docker-compose to setup the ecosystem. This file also defines the timeouts. | suite_standalone_test.go - It defines the set of tests to run against the suite. | Standalone directory - It contains resources required by the suite and likely mounted in the containers. | . A suite can also be much more complex like setting up a complete Kubernetes ecosystem. You can check the Kubernetes suite as example. .",
    "url": "https://authelia.github.io/authelia/contributing/suites.html",
    "relUrl": "/contributing/suites.html"
  }
  ,"46": {
    "title": "Traefik 1.x",
    "content": "Traefik . Traefik 1.x is a reverse proxy supported by Authelia. . Configuration . Below you will find commented examples of the following configuration: . Traefik 1.x | Authelia portal | Protected endpoint (Nextcloud) | . The below configuration looks to provide examples of running Traefik 1.x with labels to protect your endpoint (Nextcloud in this case). . Please ensure that you also setup the respective ACME configuration for your Traefik setup as this is not covered in the example below. . docker-compose.yml . version: &#39;3&#39; networks: net: driver: bridge services: traefik: image: traefik:v1.7.20-alpine container_name: traefik volumes: - &#39;/var/run/docker.sock:/var/run/docker.sock&#39; networks: - net labels: - &#39;traefik.frontend.rule=Host:traefik.example.com&#39; - &#39;traefik.port=8081&#39; ports: - 80:80 - 443:443 - 8081:8081 restart: unless-stopped command: - &#39;--api&#39; - &#39;--api.entrypoint=api&#39; - &#39;--docker&#39; - &#39;--defaultentrypoints=https&#39; - &#39;--logLevel=DEBUG&#39; - &#39;--traefiklog=true&#39; - &#39;--traefiklog.filepath=/var/log/traefik.log&#39; - &#39;--entryPoints=Name:http Address::80&#39; - &#39;--entryPoints=Name:https Address::443 TLS&#39; - &#39;--entryPoints=Name:api Address::8081&#39; authelia: image: authelia/authelia container_name: authelia volumes: - /path/to/authelia:/var/lib/authelia - /path/to/authelia/config.yml:/etc/authelia/configuration.yml:ro networks: - net labels: - &#39;traefik.frontend.rule=Host:login.example.com&#39; expose: - 9091 restart: unless-stopped environment: - TZ=Australia/Melbourne nextcloud: image: linuxserver/nextcloud container_name: nextcloud volumes: - /path/to/nextcloud/config:/config - /path/to/nextcloud/data:/data networks: - net labels: - &#39;traefik.frontend.rule=Host:nextcloud.example.com&#39; - &#39;traefik.frontend.auth.forward.address=http://authelia:9091/api/verify?rd=https://login.example.com/&#39; expose: - 443 restart: unless-stopped environment: - PUID=1000 - PGID=1000 - TZ=Australia/Melbourne .",
    "url": "https://authelia.github.io/authelia/deployment/supported-proxies/traefik1.x.html",
    "relUrl": "/deployment/supported-proxies/traefik1.x.html"
  }
  ,"47": {
    "title": "Traefik 2.x",
    "content": "Traefik2 . Traefik 2.x is a reverse proxy supported by Authelia. . Configuration . Below you will find commented examples of the following configuration: . Traefik 2.x | Authelia portal | Protected endpoint (Nextcloud) | . The below configuration looks to provide examples of running Traefik 2.x with labels to protect your endpoint (Nextcloud in this case). . Please ensure that you also setup the respective ACME configuration for your Traefik setup as this is not covered in the example below. . docker-compose.yml . version: &#39;3&#39; networks: net: driver: bridge services: traefik: image: traefik:v2.1.2 container_name: traefik volumes: - /var/run/docker.sock:/var/run/docker.sock networks: - net labels: - &#39;traefik.http.routers.api.rule=Host(`traefik.example.com`)&#39; - &#39;traefik.http.routers.api.entrypoints=https&#39; - &#39;traefik.http.routers.api.service=api@internal&#39; - &#39;traefik.http.routers.api.tls=true&#39; ports: - 80:80 - 443:443 command: - &#39;--api&#39; - &#39;--providers.docker=true&#39; - &#39;--entrypoints.http=true&#39; - &#39;--entrypoints.http.address=:80&#39; - &#39;--entrypoints.https=true&#39; - &#39;--entrypoints.https.address=:443&#39; - &#39;--log=true&#39; - &#39;--log.level=DEBUG&#39; - &#39;--log.filepath=/var/log/traefik.log&#39; authelia: image: authelia/authelia container_name: authelia volumes: - /path/to/authelia:/var/lib/authelia - /path/to/authelia/config.yml:/etc/authelia/configuration.yml:ro networks: - net labels: - &#39;traefik.http.routers.authelia.rule=Host(`login.example.com`)&#39; - &#39;traefik.http.routers.authelia.entrypoints=https&#39; - &#39;traefik.http.routers.authelia.tls=true&#39; expose: - 9091 restart: unless-stopped environment: - TZ=Australia/Melbourne nextcloud: image: linuxserver/nextcloud container_name: nextcloud volumes: - /path/to/nextcloud/config:/config - /path/to/nextcloud/data:/data networks: - net labels: - &#39;traefik.http.routers.nextcloud.rule=Host(`nextcloud.example.com`)&#39; - &#39;traefik.http.routers.nextcloud.entrypoints=https&#39; - &#39;traefik.http.routers.nextcloud.tls=true&#39; - &#39;traefik.http.routers.nextcloud.middlewares=authelia&#39; - &#39;traefik.http.middlewares.authelia.forwardAuth.address=http://authelia:9091/api/verify?rd=https://login.example.com/&#39; expose: - 443 restart: unless-stopped environment: - PUID=1000 - PGID=1000 - TZ=Australia/Melbourne .",
    "url": "https://authelia.github.io/authelia/deployment/supported-proxies/traefik2.x.html",
    "relUrl": "/deployment/supported-proxies/traefik2.x.html"
  }
  
}